
1. prime number checker
a= int(input("enter a number"))
for i in range(2, a):
    if  a%i==0:
        print("not prime")
        break
else:
    print("prime")


2. fibonacci series
n = int(input("Enter number of terms: "))
a, b = 0, 1
for _ in range(n):
    print(a, end=" ")
    a, b = b, a + b


3.pal
n = input("Enter a number: ")
print("Palindrome" if n == n[::-1] else "Not Palindrome")




4.sum of n number
a=int(input("Enter a number"))
i=1
sum =0
while i<=a:
    sum+=i
    i+=1
print(sum)

5. fact
def factorial(n):
    if n==0 or n==1:
        return 1
    return n*factorial(n-1)

n=int(input("enter "))
print(factorial(n))



6. Armstrong Number
def is_armstrong(num):
    temp = num
    digits = len(str(num))
    sum_ = 0
    while temp > 0:
        digit = temp % 10
        sum_ += digit ** digits
        temp //= 10
    return num == sum_

7. Palindrome
def is_palindrome(s):
    s = str(s)
    return s == s[::-1]

8. equi triangle pattern
n=int(input("enter a number "))
for i in range(1, n+1):
    print(" "*(n-i), end="")
    print("*"*(2*i-1), end="")
    print("")


9. left another triangle pattern                                           
n=int(input("enter a number "))
for i in range(1, n+1):
    print("*"*i, end ="")
    print("")































































Q6 statistical operation
x=c (12,23,25,23,28)
mean(x)
max(x)
length(x)
x[6]=30
length(x)
var(x)
sqrt(var(x))
sd(x)




exp 1--------
data("longley")
force("longley")
attributes("longley")
str("longley")
class("longley")
tail("longley")
names("longley")
longley[1:5]
dim()
head()


exp 2----------
> var_1 = c(0,1,2,3)
> print(var_1)
> var_2 =c("learn","r")
> print(var_2)
> c(TRUE,1)->var_3
> print(var_3)
ls()
> v=c(2,5,6)
> t=c(8,3,4)
> print(v+t)
> print(v_t)
> print(v*t)
> print(v^t)


exp 3-----------
ploting:
> x<-c(1,2,3,4,5)
> y<-c(3,7,8,9,12)
> plot(x,y)
point with labels:
> plot(1:10,main="my graph",xlab = "the x-axis",ylab="the y axis")
multiple lines:
 line1<-c(1,2,3,4,5,10)
> line2<-c(2,5,7,8,10)
> plot(line1,type = "l",col="blue")
> lines(line2,type="l",col="red")

scatter plots:
> x<- c(1,2,3,4,5)
> y<- c(2,5,6,9,2)
> print(x,y)

compare plots:
> x1<-c (5,7,8,7,2,2,9,4,11,12)
> y1<-c(99,86,87,88,111,103,87,94,78)
> x2<-c(2,2,8,1,15,8,9,7,3,11)
> y2<-c(100,105,84,105,90,99,90,95,94,100)
> plot(x1,y1,main="observation of cars",xlab = "car age", ylab = "car speed",col="red", cex=2)


pie chart
> x<-c(10,20,30,40)
> mylable<-c("a","b","c","d")
> colors<-c("blue","yellow","green","black")
> pie(x,label=mylable,main="fruits",col=colors)

bar chart
> x<-c("A","b","c","d")
> y<-c(2,4,6,8)
> barplot(y,names.arg = x,density = 10)



































//------------------------stack
#include <stdio.h>
#define MAX 10
int stack[MAX] = {10, 20, 30, 40}, top = 3;
void display() {
    if (top == -1)
        printf("Stack is empty.\n");
    else {
        printf("Current Stack: ");
        for (int i = 0; i <= top; i++) printf("%d ", stack[i]);
        printf("\n");
    }
}
void push() {
    if (top == MAX - 1)
        printf("Stack Overflow! Cannot push.\n");
    else {
        int value;
        printf("Enter value to push: ");
        scanf("%d", &value);
        stack[++top] = value;
        printf("%d pushed into the stack.\n", value);
        display();
    }
}
void pop() {
    if (top == -1)
        printf("Stack Underflow! Cannot pop.\n");
    else {
        printf("%d popped from the stack.\n", stack[top--]);
        display();
    }
}
int main() {
    int choice;
    printf("Initial Stack:\n");
    display();
    while (1) {
        printf("\n1. Push\n2. Pop\n3. Exit\nChoice: ");
        scanf("%d", &choice);
        if (choice == 1) push();
        else if (choice == 2) pop();
        else if (choice == 3) break;
        else printf("Invalid choice! Try again.\n");
    }
    printf("Exiting program.\n");
    return 0;
}



//-----------------------------------------Queue
#include <stdio.h>
#define MAX 10
int queue[MAX] = {10, 20, 30, 40}, front = 0, rear = 3;
void display() {
    if (front > rear)
        printf("Queue is empty.\n");
    else {
        printf("Current Queue: ");
        for (int i = front; i <= rear; i++) printf("%d ", queue[i]);
        printf("\n");
    }
}
void enqueue() {
    if (rear == MAX - 1)
        printf("Queue Overflow! Cannot enqueue.\n");
    else {
        int value;
        printf("Enter value to enqueue: ");
        scanf("%d", &value);
        queue[++rear] = value;
        printf("%d enqueued into the queue.\n", value);
        display();
    }
}
void dequeue() {
    if (front > rear)
        printf("Queue Underflow! Cannot dequeue.\n");
    else {
        printf("%d dequeued from the queue.\n", queue[front++]);
        display();
    }
}
int main() {
    int choice;
    printf("Initial Queue:\n");
    display();
    while (1) {
        printf("\n1. Enqueue\n2. Dequeue\n3. Exit\nChoice: ");
        scanf("%d", &choice);
        if (choice == 1) enqueue();
        else if (choice == 2) dequeue();
        else if (choice == 3) break;
        else printf("Invalid choice! Try again.\n");
    }
    printf("Exiting program.\n");
    return 0;
}






//--------------------------------------single linked list insertion at any perticular position----------------------------
#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to display the linked list
void display(struct Node* head) {
    printf("Linked list: ");
    while (head) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\n");
}

// Function to insert a node at a specific position
void insertAtPosition(struct Node** head, int value, int position) {
    struct Node* newNode = createNode(value);
    if (position == 1) {
        newNode->next = *head;
        *head = newNode;
    } else {
        struct Node* temp = *head;
        for (int i = 1; i < position - 1 && temp; i++)
            temp = temp->next;
        if (!temp) { printf("Invalid position!\n"); free(newNode); return; }
        newNode->next = temp->next;
        temp->next = newNode;
    }
    printf("Inserted %d at position %d.\n", value, position);
}
// Main function
int main() {
    // Predefined linked list
    struct Node *head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    int choice, value, position;
    display(head);

    while (1) {
        printf("\n1. Insert at position\n2. Exit\nChoice: ");
        scanf("%d", &choice);
        if (choice == 1) {
            printf("Enter value and position: ");
            scanf("%d %d", &value, &position);
            insertAtPosition(&head, value, position);
            display(head);
        }else if (choice == 2)
            break;
        else
            printf("Invalid choice! Try again.\n");
    }
    return 0;
}


//-------------------------------------------------single linked list deletion at any perticular position-------------------------

#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}

// Function to display the linked list
void display(struct Node* head) {
    printf("Linked list: ");
    while (head) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\n");
}

// Function to delete a node at a specific position
void deleteAtPosition(struct Node** head, int position) {
    if (!*head) {
        printf("List is empty!\n");
        return;
    }
    struct Node* temp = *head;

    // If the head is to be deleted
    if (position == 1) {
        *head = temp->next;
        printf("Deleted %d from position %d.\n", temp->data, position);
        free(temp);
        return;
    }

    // Traverse to the (position-1)th node
    for (int i = 1; i < position - 1 && temp; i++)
        temp = temp->next;

    // If position is invalid
    if (!temp || !temp->next) {
        printf("Invalid position!\n");
        return;
    }

    // Delete the node at the desired position
    struct Node* nodeToDelete = temp->next;
    temp->next = nodeToDelete->next;
    printf("Deleted %d from position %d.\n", nodeToDelete->data, position);
    free(nodeToDelete);
}

// Main function
int main() {
    // Predefined linked list
    struct Node *head = createNode(10);
    head->next = createNode(20);
    head->next->next = createNode(30);
    head->next->next->next = createNode(40);

    int choice, position;
    display(head);

    while (1) {
        printf("\n1. Delete at position\n2. Exit\nChoice: ");
        scanf("%d", &choice);
        if (choice == 1) {
            printf("Enter position: ");
            scanf("%d", &position);
            deleteAtPosition(&head, position);
            display(head);
        }
        else if (choice == 3)
            break;
        else
            printf("Invalid choice! Try again.\n");
    }
    return 0;
}






//-----------------------------------------------------------------------double linked list insert and delete at any perticular position
#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    newNode->prev = newNode->next = NULL;
    return newNode;
}

// Function to display the doubly linked list
void display(struct Node* head) {
    printf("Doubly linked list: ");
    while (head) {
        printf("%d <-> ", head->data);
        head = head->next;
    }
    printf("NULL\n");
}

// Function to insert at a specific position
void insertAtPosition(struct Node** head, int value, int position) {
    struct Node* newNode = createNode(value);
    if (position == 1) { // Insert at head
        newNode->next = *head;
        if (*head) (*head)->prev = newNode;
        *head = newNode;
    } else {
        struct Node* temp = *head;
        for (int i = 1; i < position - 1 && temp; i++)
            temp = temp->next;
        if (!temp) return printf("Invalid position!\n"), free(newNode), void();
        newNode->next = temp->next;
        if (temp->next) temp->next->prev = newNode;
        temp->next = newNode;
        newNode->prev = temp;
    }
    printf("Inserted %d at position %d.\n", value, position);
}

// Function to delete at a specific position
void deleteAtPosition(struct Node** head, int position) {
    if (!*head) return printf("List is empty!\n"), void();
    struct Node* temp = *head;

    if (position == 1) { // Delete head
        *head = temp->next;
        if (*head) (*head)->prev = NULL;
    } else {
        for (int i = 1; i < position && temp; i++)
            temp = temp->next;
        if (!temp) return printf("Invalid position!\n"), void();
        if (temp->next) temp->next->prev = temp->prev;
        if (temp->prev) temp->prev->next = temp->next;
    }
    printf("Deleted %d from position %d.\n", temp->data, position);
    free(temp);
}

// Main function
int main() {
    // Predefined doubly linked list
    struct Node *head = createNode(10), *node2 = createNode(20);
    struct Node *node3 = createNode(30), *node4 = createNode(40);
    head->next = node2, node2->prev = head;
    node2->next = node3, node3->prev = node2;
    node3->next = node4, node4->prev = node3;

    int choice, value, position;
    display(head);

    while (1) {
        printf("\n1. Insert at position\n2. Delete at position\n3. Display\n4. Exit\nChoice: ");
        scanf("%d", &choice);
        if (choice == 1) {
            printf("Enter value and position: ");
            scanf("%d %d", &value, &position);
            insertAtPosition(&head, value, position);
            display(head);
        } else if (choice == 2) {
            printf("Enter position: ");
            scanf("%d", &position);
            deleteAtPosition(&head, position);
            display(head);
        } else if (choice == 3)
            display(head);
        else if (choice == 4)
            break;
        else
            printf("Invalid choice! Try again.\n");
    }
    return 0;
}



#-------------------------------php
 <?php
$conn = new mysqli('localhost', 'root', '', 'user_registration') or die("Connection failed: " . $conn->connect_error);
$message = '';
if ($_SERVER['REQUEST_METHOD'] == 'POST') {
    $password = password_hash($_POST['password'], PASSWORD_DEFAULT);
    $stmt = $conn->prepare("INSERT INTO users (email, password) VALUES (?, ?)");
    $stmt->bind_param("ss", $_POST['email'], $password);
    $message = $stmt->execute() ? "Registration successful!" : "Error: " . $stmt->error;
}
?>

<!DOCTYPE html>
<html lang="en"> 
<head>
    <title>Register</title>
</head>
<body>
    <form method="POST">
        <h2>Register</h2>
        <p><?= $message; ?></p>
        <input type="email" name="email" placeholder="Email" required>
        <input type="password" name="password" placeholder="Password" required>
        <button type="submit">Register</button>
    </form>
</body>
</html>






# UpperLowerConversion

<!DOCTYPE html>
<html>
<head>
  <title>Form Object Example</title>
  <script>
    function setCase(caseSpec) {
      const firstName = document.form1.firstName;
      const lastName = document.form1.lastName;
      
      if (caseSpec === 'upper') {
        firstName.value = firstName.value.toUpperCase();
        lastName.value = lastName.value.toUpperCase();
      } else {
        firstName.value = firstName.value.toLowerCase();
        lastName.value = lastName.value.toLowerCase();
      }
    }
  </script>
</head>
<body>
  <form name="form1">
    <b>First name:</b>
    <input type="text" name="firstName" size="20"><br>
    <b>Last name:</b>
    <input type="text" name="lastName" size="20"><p>
    <input type="button" value="Names to Uppercase" onclick="setCase('upper')">
    <input type="button" value="Names to Lowercase" onclick="setCase('lower')">
  </form>
</body>
</html>




#---------------------------------------------xml

<?xml version="1.0" encoding="UTF-8"?> 
<?xml-stylesheet type="text/css" href="Rule.css"?>  
<books> 
	<heading>Welcome  </heading> 
	<book> 
		<title>Title -: Web Programming</title> 
		<author>Author -: Chrisbates</author> 
		<publisher>Publisher -: Wiley</publisher> 
		<edition>Edition -: 3</edition> 
		<price> Price -: 300</price> 
	</book> 
	<book> 
		<title>Title -: Internet world-wide-web</title> 
		<author>Author -: Ditel</author> 
		<publisher>Publisher -: Pearson</publisher> 
		<edition>Edition -: 3</edition> 
		<price>Price -: 400</price> 
	</book> 
</books> 
books { 
	color: white; 
	background-color : gray; 
	width: 100%; 
} 
heading { 
	color: green; 
	font-size : 40px; 
	background-color : powderblue; 
} 
heading, title, author, publisher, edition, price { 
	display : block; 
} 
title { 
	font-size : 25px; 
	font-weight : bold; 
} 




#----------------------------------- upperlower
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Form Object Example</title>
    <script>
        const setCase = caseSpec => {
            document.querySelectorAll('form[name="form1"] input[type="text"]').forEach(input => {
                input.value = caseSpec === 'upper' ? input.value.toUpperCase() : input.value.toLowerCase();
            });
        };
    </script>
</head>
<body>
    <form name="form1">
        <b>First name:</b>
        <input type="text" name="firstName" size="20"><br>
        <b>Last name:</b>
        <input type="text" name="lastName" size="20"><p>
        <input type="button" value="Names to Uppercase" onclick="setCase('upper')">
        <input type="button" value="Names to Lowercase" onclick="setCase('lower')">
    </form>
</body>
</html>


#----------------------------- word count
<!DOCTYPE html>
<html lang="en">
<body>
    <textarea id="textInput" placeholder="Type here..."></textarea><br>
    <button onclick="countWords()">Count</button>
    <p id="result"></p>
    <script>
        function countWords() {
            const text = document.getElementById('textInput').value;
            const count = text.split(/\s+/).filter(word => word).length;
            document.getElementById('result').textContent = 'Word Count: ' + count;
        }
    </script>
</body>
</html>



#----------------------valid no
<!DOCTYPE html>
<html lang="en">
<body>
    <label for="phoneInput">Phone Number:</label>
    <input type="text" id="phoneInput" placeholder="Enter your phone number">
    <button onclick="validatePhone()">Validate</button>

    <p id="result"></p>
    <script>
        function validatePhone() {
            const phone = document.getElementById('phoneInput').value;
            const result = document.getElementById('result');
            result.textContent = phone.match(/^\d{10}$/) ? 'Valid phone number!' : 'Invalid phone number. Please enter 10 digits.';
        }
    </script>
</body>
</html>



#------------------------------------on submit
<!DOCTYPE html>
<html lang="en">

<body>
    <form id="myForm" onsubmit="handleSubmit(event)">
        <label for="name">Name:</label>
        <input type="text" id="name" required>
        <button type="submit">Submit</button>
    </form>
    <script>
        function handleSubmit(event) {
            event.preventDefault(); // Prevent the form from refreshing the page
            const name = document.getElementById('name').value; // Get the input value
            alert('Hello' ); // Show an alert
        }
    </script>
</body>
</html>
























//---------------------------------------------------traversal

#include <stdio.h>

void traverseArray(int arr[], int size) {
    printf("Array elements: ");
    for(int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main() {
    int n;
    printf("Enter the number of elements in the array: ");
    scanf("%d", &n);

    int arr[n];
    printf("Enter the elements of the array:\n");
    for(int i = 0; i < n; i++) {
        scanf("%d", &arr[i]);
    }

    traverseArray(arr, n);
    
    return 0;
}


//----------------------------------array insertion at any specific position------------------------------------
#include <stdio.h>

void insertAtPosition(int arr[], int *size, int element, int position) {
    for (int i = *size; i > position; i--) arr[i] = arr[i - 1];
    arr[position] = element;
    (*size)++;
}

void traverseArray(int arr[], int size) {
    for (int i = 0; i < size; i++) printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int n, element, position;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr[n + 1];
    printf("Enter elements: ");
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);
    printf("Enter element to insert and position: ");
    scanf("%d %d", &element, &position);
    insertAtPosition(arr, &n, element, position);
    traverseArray(arr, n);
    return 0;
}


//------------------------array deletion at any specific position---------------------------

#include <stdio.h>
void deleteAtPosition(int arr[], int *size, int position) {
    for (int i = position; i < *size - 1; i++) arr[i] = arr[i + 1];
    (*size)--;
}

void traverseArray(int arr[], int size) {
    for (int i = 0; i < size; i++) printf("%d ", arr[i]);
    printf("\n");
}

int main() {
    int n, position;
    printf("Enter number of elements: ");
    scanf("%d", &n);
    int arr[n];
    printf("Enter elements: ");
    for (int i = 0; i < n; i++) scanf("%d", &arr[i]);
    printf("Enter position to delete: ");
    scanf("%d", &position);
    deleteAtPosition(arr, &n, position);
    traverseArray(arr, n);
    return 0;
}







// searching single linked list
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

void searchList(struct Node* head, int key) {
    struct Node* current = head;
    int position = 0;
    while (current != NULL) {
        if (current->data == key) {
            printf("Element %d found at position %d\n", key, position);
            return;
        }
        current = current->next;
        position++;
    }
    printf("Element %d not found\n", key);
}

void traverseList(struct Node* head) {
    while (head != NULL) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\n");
}

void insertNode(struct Node** head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = *head;
    *head = newNode;
}

int main() {
    struct Node* head = NULL;
    int n, data, key;
    printf("Enter number of nodes to insert: ");
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        printf("Enter data for node %d: ", i + 1);
        scanf("%d", &data);
        insertNode(&head, data);
    }

    printf("Enter element to search: ");
    scanf("%d", &key);
    searchList(head, key);

    traverseList(head);
    return 0;
}










--------------------insert element at any perticular location in circular linked list------------

#include <stdio.h>
#include <stdlib.h>

// Define a node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at a given position in a circular linked list
void insertAtPosition(struct Node** head, int data, int position) {
    struct Node* newNode = createNode(data);
    struct Node* temp = *head;

    // If the list is empty, create a single node circular linked list
    if (*head == NULL) {
        newNode->next = newNode;
        *head = newNode;
        return;
    }

    // If inserting at the head (position 1)
    if (position == 1) {
        // Traverse to the last node to make it circular after insertion
        while (temp->next != *head) {
            temp = temp->next;
        }
        newNode->next = *head;
        temp->next = newNode;
        *head = newNode;
        return;
    }

    // Traverse to the position before where the new node is to be inserted
    for (int i = 1; i < position - 1 && temp->next != *head; i++) {
        temp = temp->next;
    }

    newNode->next = temp->next;
    temp->next = newNode;
}

// Function to print the circular linked list
void printList(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }
    struct Node* temp = head;
    do {
        printf("%d ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("\n");
}

int main() {
    struct Node* head = NULL;
    
    // Creating a circular linked list
    insertAtPosition(&head, 10, 1); // Insert 10 at position 1
    insertAtPosition(&head, 20, 2); // Insert 20 at position 2
    insertAtPosition(&head, 30, 3); // Insert 30 at position 3
    insertAtPosition(&head, 40, 2); // Insert 40 at position 2

    printf("Circular Linked List: ");
    printList(head);

    return 0;
}






----------delete element at any perticular location in circular linked list--------

#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Insert a node at the end of the circular linked list
void insertNode(struct Node** head, int data) {
    struct Node* newNode = createNode(data);
    if (*head == NULL) {
        *head = newNode;
        newNode->next = *head;
    } else {
        struct Node* temp = *head;
        while (temp->next != *head) temp = temp->next;
        temp->next = newNode;
        newNode->next = *head;
    }
}

// Delete node at a specific position
void deleteNode(struct Node** head, int pos) {
    if (*head == NULL) {
        printf("List is empty.\n");
        return;
    }

    struct Node* temp = *head;
    
    // If deleting the first node (head)
    if (pos == 1) {
        while (temp->next != *head) temp = temp->next;
        struct Node* toDelete = *head;
        temp->next = (*head)->next;
        *head = (*head)->next;
        free(toDelete);
        return;
    }

    struct Node* prev = NULL;
    for (int i = 1; i < pos; i++) {
        prev = temp;
        temp = temp->next;
        if (temp == *head) {  // Position out of range
            printf("Position out of range.\n");
            return;
        }
    }

    prev->next = temp->next;
    free(temp);
}

// Display the circular linked list
void displayList(struct Node* head) {
    if (head == NULL) {
        printf("List is empty.\n");
        return;
    }
    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);
    printf("(back to head)\n");
}

int main() {
    struct Node* head = NULL;
    int choice, data, pos;

    // Menu for inserting and deleting nodes
    while (1) {
        printf("\n1. Insert Node\n2. Delete Node\n3. Display List\n4. Exit\n");
        printf("Enter your choice: ");
        scanf("%d", &choice);

        switch (choice) {
            case 1:
                printf("Enter data to insert: ");
                scanf("%d", &data);
                insertNode(&head, data);
                break;
            case 2:
                printf("Enter position to delete: ");
                scanf("%d", &pos);
                deleteNode(&head, pos);
                break;
            case 3:
                printf("Circular Linked List: ");
                displayList(head);
                break;
            case 4:
                exit(0);
            default:
                printf("Invalid choice. Try again.\n");
        }
    }

    return 0;
}





def tower_of_hanoi(n, source, auxiliary, target):
    if n == 1:
        print("Move disk 1 from rod", source, "to rod", target)
        return
    tower_of_hanoi(n-1, source, target, auxiliary)
    print("Move disk", n, "from rod", source, "to rod", target)
    tower_of_hanoi(n-1, auxiliary, source, target)
num_disks = int(input("Enter the number of disks: "))
source_peg = input("Enter the name of the source peg: ")
auxiliary_peg = input("Enter the name of the auxiliary peg: ")
target_peg = input("Enter the name of the target peg: ")

tower_of_hanoi(num_disks, source_peg, auxiliary_peg, target_peg)


#String is Palindrome or Not
def is_palindrome(input_string):
       input_string = input_string.lower().replace(" ", "")
    return input_string == input_string[::-1]
input_string = input("Enter a string: ")
if is_palindrome(input_string):
    print("The string is a palindrome.")
else:
    print("The string is not a palindrome.")





#bfs dfs

adj_list={'A':['C','D','B'],'B':['E','C'],'C':['D'],'D':['E'],'E':[]}
visited=set()

def dfs(visited,adj_list,root):
    if root not in visited:
        print(root)
        visited.add(root)
        for neighbour in adj_list[root]:
            dfs(visited,adj_list,neighbour)

def bfs(visited,adj_list, queue):
    if queue:
        node = queue.pop(0)
        if node not in visited:
            print(node)
            visited.add(node)
            for neighbour in adj_list[node]:
                queue.append(neighbour)
        bfs(visited,adj_list, queue)

#bfs(visited, adj_list, ['A'])
dfs(visited, adj_list, 'A')



#water_jug_problem
def water_jug_problem(cap1, cap2, target):
    visited = set()
    stack = [(0, 0, "Initial state")]
    visited.add((0, 0))
    steps = []

    while stack:
        j1, j2, step = stack.pop()
        steps.append(step)

        if j1 == target or j2 == target:
            return True, steps

        # Fill jug1
        if (j1 < cap1) and ((cap1, j2) not in visited):
            stack.append((cap1, j2, f"Fill Jug1: ({cap1},{j2})"))
            visited.add((cap1, j2))

        # Fill jug2
        if (j2 < cap2) and ((j1, cap2) not in visited):
            stack.append((j1, cap2, f"Fill Jug2: ({j1},{cap2})"))
            visited.add((j1, cap2))

        # Empty jug1
        if (j1 > 0) and ((0, j2) not in visited):
            stack.append((0, j2, f"Empty Jug1: (0,{j2})"))
            visited.add((0, j2))

        # Empty jug2
        if (j2 > 0) and ((j1, 0) not in visited):
            stack.append((j1, 0, f"Empty Jug2: ({j1},0)"))
            visited.add((j1, 0))

        # Pour from jug1 to jug2
        pour_amt = min(j1, cap2 - j2)
        if pour_amt > 0:
            new_j1 = j1 - pour_amt
            new_j2 = j2 + pour_amt
            if (new_j1, new_j2) not in visited:
                stack.append((new_j1, new_j2, f"Pour from Jug1 to Jug2: ({new_j1},{new_j2})"))
                visited.add((new_j1, new_j2))

        # Pour from jug2 to jug1
        pour_amt = min(j2, cap1 - j1)
        if pour_amt > 0:
            new_j1 = j1 + pour_amt
            new_j2 = j2 - pour_amt
            if (new_j1, new_j2) not in visited:
                stack.append((new_j1, new_j2, f"Pour from Jug2 to Jug1: ({new_j1},{new_j2})"))
                visited.add((new_j1, new_j2))

    return False, steps
cap1 = int(input("Enter the capacity of Jug1: "))
cap2 = int(input("Enter the capacity of Jug2: "))
target = int(input("Enter the target amount of water: "))

print("Steps to achieve the target amount of water:")
found, steps = water_jug_problem(cap1, cap2, target)
if found:
    for i, step in enumerate(steps):
        print(f"Step {i + 1}: {step}")
else:
    print("Target amount of water cannot be achieved.")





#water jug
def elseR():
  print("Rule Denied.")
  return x,y

def apply_rule(ch , x , y):
  if ch == 1:
    if x<j1:
      return j1,y
    else:
      elseR()
  if ch == 2:
    if y<j2:
      return x,j2
    else:
      elseR()
  if ch == 3:
    if x>0 and x+y<=j2:
      return 0,x+y
    else:
      elseR()
  if ch == 4:
    if y>0 and x+y<=j1:
      return x+y,0
    else:
      elseR()
  if ch == 5:
    if x>0 and x+y>=j2:
      return x-(j2-y),j2
    else:
      elseR()
  if ch == 6:
    if y>0 and x+y>=j1:
      return j1,y-(j1-x)
    else:
      elseR()
  if ch == 7:
    if x>0:
      return 0,y
    else:
      elseR()
  if ch == 8:
    if y>0:
      return x,0
    else:
      elseR()

j1 = int(input("Capacity of jug 1: "))
j2 = int(input("Capacity of jug 2: "))

g = int(input("Amount of watter to be measured: "))

x = y = 0
while (True):
  if x==g or y==g:
    print("GOAL ACHIVED.")
    break
  else:
    print("====================Rules====================")
    print("Rule 1: Fill Jug 1.")
    print("Rule 2: Fill Jug 2.")
    print("Rule 3: Transform all water from jug 1 to jug 2.")
    print("Rule 4: Transform all water from jug 2 to jug 1.")
    print("Rule 5: Transform some water from jug 1 to jug 2 until jug 2 is full.")
    print("Rule 6: Transform some water from jug 2 to jug 1 until jug 1 is full.")
    print("Rule 7: Empty jug 1")
    print("Rule 8: Empty jug 2")
    ch = int(input("Enter the rule to apply: "))
    x ,y = apply_rule(ch,x,y)
    print("====================State====================")
    print("Current State: ",x,y)



#A*
def aStarAlgo(start_node, stop_node):
         
        open_set = set(start_node) 
        closed_set = set()
        g = {} 
        parents = {}
        g[start_node] = 0
        parents[start_node] = start_node
         
        while len(open_set) > 0:
            n = None
            for v in open_set:
                if n == None or g[v] + heuristic(v) < g[n] + heuristic(n):
                    n = v
            if n == stop_node or Graph_nodes[n] == None:
                pass
            else:
                for (m, weight) in get_neighbors(n):

                    if m not in open_set and m not in closed_set:
                        open_set.add(m)
                        parents[m] = n
                        g[m] = g[n] + weight

                    else:
                        if g[m] > g[n] + weight:
                            g[m] = g[n] + weight
                            parents[m] = n

                            if m in closed_set:
                                closed_set.remove(m)
                                open_set.add(m)
            if n == None:
                print('Path does not exist!')
                return None

            if n == stop_node:
                path = []
                while parents[n] != n:
                    path.append(n)
                    n = parents[n]
                path.append(start_node)
                path.reverse()
                print('Path found: {}'.format(path))
                return path
            open_set.remove(n)
            closed_set.add(n)
        print('Path does not exist!')
        return None
    
def get_neighbors(v):
    if v in Graph_nodes:
        return Graph_nodes[v]
    else:
        return None

def heuristic(n):
        H_dist = {
            'A': 11,
            'B': 6,
            'C': 99,
            'D': 1,
            'E': 7,
            'G': 0,
        }
 
        return H_dist[n]
 
Graph_nodes = {
    'A': [('B', 2), ('E', 3)],
    'B': [('C', 1),('G', 9)],
    'C': None,
    'E': [('D', 6)],
    'D': [('G', 1)],
}
aStarAlgo('A', 'G')











Write a python program to check whether the given number is prime or not?
num = 11
# If given number is greater than 1
if num > 1:
	# Iterate from 2 to n / 2
	for i in range(2, int(num/2)+1):
		# If num is divisible by any number between
		# 2 and n / 2, it is not prime
		if (num % i) == 0:
			print(num, "is not a prime number")
			break
	else:
		print(num, "is a prime number")
else:
	print(num, "is not a prime number")


# Python program to shuffle a deck of card
# importing modules
import itertools, random
# make a deck of cards
deck = list(itertools.product(range(1,14),['Spade','Heart','Diamond','Club']))
# shuffle the cards
random.shuffle(deck)
# draw five cards
print("You got:")
for i in range(5):
   print(deck[i][0], "of", deck[i][1])



# Python program to display the Fibonacci sequence
def recur_fibo(n):
   if n <= 1:
       return n
   else:
       return(recur_fibo(n-1) + recur_fibo(n-2))
nterms = 10
# check if the number of terms is valid
if nterms <= 0:
   print("Plese enter a positive integer")
else:
   print("Fibonacci sequence:")
   for i in range(nterms):
       print(recur_fibo(i))



# Python program to display all the prime numbers within an interval
lower = 900
upper = 1000
print("Prime numbers between", lower, "and", upper, "are:")
for num in range(lower, upper + 1):
   # all prime numbers are greater than 1
   if num > 1:
       for i in range(2, num):
           if (num % i) == 0:
               break
       else:
           print(num)




#simple chatbot
def chat():
    responses = {
        "hi": "Hello!",
        "hello": "Hi there!",
        "how are you?": "I'm just a bot, but I'm doing fine. How about you?",
        "what's your name?": "I'm just a bot, you can call me ChatBot!",
        "bye": "Goodbye! Take care!",
    }
    print("Hello! I'm a simple chatbot.")
    print("You can type 'bye' to exit the conversation.")
    while True:
        user_input = input("You: ").strip().lower()

        if user_input == 'bye':
            print("Bot: Goodbye!")
            break
        elif user_input in responses:
            print("Bot:", responses[user_input])
        else:
            print("Bot: I'm just a simple bot and I didn't understand that. Can you please rephrase?")
chat()




//chat bot with json
import json
import random
def load_responses():
    with open('responses.json') as file:
        return json.load(file)
def chatbot_response(user_input, responses):
    return random.choice(responses.get(user_input.lower(), ["I'm not sure how to respond to that."]))
responses = load_responses()
print("Simple Chatbot: Hello! Type 'bye' to exit.")
while True:
    user_input = input("You: ").lower()
    if user_input == 'bye':
        print("Simple Chatbot: Goodbye!")
        break
    print("Simple Chatbot:", chatbot_response(user_input, responses))




1.	Write a python program to implement List operations (Nested List, Length, Concatenation, Membership, Iteration, Indexing and Slicing)?
# Nested List
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print("nested list = ",nested_list)
# Length
lan = len(nested_list)
print("length of the list= ",lan)
# Concatenation
list1 = [1, 2, 3]
list2 = [4, 5, 6]
print("Concatenation =", list1 + list2)
# Membership
ele_present = 4 in list1
print("Membership check= ",ele_present)
# Iteration
print("Iteration =")
for item in list1:
    print(item)
# Indexing and Slicing
element = list1[2]
print("Indexing= ",element)
sliced_list = list1[1:3]
print("Slicing= ",sliced_list)



2.	Write a python program to implement List methods (Add, Append, Extend & Delete).
# Add
list1 = [1, 2, 3]
list1[0] += 5
# Append
list1.append(4)
# Extend
list1.extend([5, 6, 7])
# Delete
del list1[2]


3.	Write a python program to Check Whether a String is Palindrome or Not
def is_palindrome(input_string):
    # Convert the input string to lowercase and remove spaces
    input_string = input_string.lower().replace(" ", "")
    # Check if the string is equal to its reverse
    return input_string == input_string[::-1]
input_string = input("Enter a string: ")
if is_palindrome(input_string):
    print("The string is a palindrome.")
else:
    print("The string is not a palindrome.")





4.	Write a python program to Remove Punctuations from a String.

def remove_punctuation(input_string):
    punctuations = '''!()-[]{};:'"\,<>./?@#$%^&*_~'''
    cleaned_string = ""
    for char in input_string:
        if char not in punctuations:
            cleaned_string += char
    return cleaned_string
input_string = input("Enter a string with punctuations: ")
cleaned_string = remove_punctuation(input_string)
print("String without punctuations:", cleaned_string)






5.	Write a program in python to implement Depth-First Traversal
# Assuming a graph represented as an adjacency list
graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [6], 6: []}
def depth_first_traversal(node, visited):
    if node not in visited:
        print(node, end=" ")
        visited.add(node)
        for neighbor in graph[node]:
            depth_first_traversal(neighbor, visited)
visited_nodes = set()
depth_first_traversal(1, visited_nodes)


6.	Write a program in python to implement Breadth-First Traversal
from collections import deque
# Assuming a graph represented as an adjacency list
graph = {1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [6], 6: []}
def breadth_first_traversal(start):
    visited = set()
    queue = deque([start])
    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node, end=" ")
            visited.add(node)
            queue.extend(graph[node])
breadth_first_traversal(1)

